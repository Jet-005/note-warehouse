**数据类型检测的方式有哪些**
1. typeof：
> 因为typeof直接根据变量值得内存标识符进行判断。
> typeof 一般用来判断 number、string、boolean、undefined、object、function、symbol这七种类型。
> 而js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息：
> 000：对象 010：浮点数 100：字符串 110：布尔 1：整数
> 那null为什么也是object呢？因为null的所有机器码均为0，所以typeof检测的时候也认为是对象了。

2.instanceof：内部运行机制是判断在其原型链中能否找到该类型的原型，只能正确判断引用数据类型，而不能判断基本数据类型。instanceof 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性
3.constructor：constructor 有两个作用，一是判断数据的类型，二是对象实例通过constrcutor 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，constructor 就不能用来判断数据类型了

4.Object.prototype.toString.call()：使用 Object 对象的原型方法toString 来判断数据类型
```
console.log(Object.prototype.toString.call(2)); // [object Number]
console.log(Object.prototype.toString.call(true)); // [object Boolean]
console.log(Object.prototype.toString.call("str")) // [object String]
console.log(Object.prototype.toString.call([])); // [object Array]
console.log(Object.prototype.toString.call(function () {})); // [object Function]
console.log(Object.prototype.toString.call({})); // [object Object]
console.log(Object.prototype.toString.call(undefined)); // [object Undefined]
console.log(Object.prototype.toString.call(null)); // [object Null]
由于toString是Object的原型方法，而Array/Function等类型作为Object的实例，重写了toString方法，所以调用的是对应的重写之后的toString方法
```

**Object.is() 与比较操作符 全等于跟双等于 的区别？**

```
==会进行强制类型转化后再进行比较，===不会进行强制类型转化

Object.is一般情况下与===判断相同，主要是处理一些特殊情况，如-0，+0，两个NaN之间的比较
```

**JavaScript 中的包装类型？**
在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象
![image.png](https://obsi-jet.oss-cn-beijing.aliyuncs.com/img/20240304200049.png)
JavaScript 将 'abc' 在 后 台 转 换 成String('abc')，然后再访问其 length 属性
JavaScript 也可以使用 Object 函数显式地将基本类型转换为包装类型：![image.png](https://obsi-jet.oss-cn-beijing.aliyuncs.com/img/20240304200335.png)

![image.png](https://obsi-jet.oss-cn-beijing.aliyuncs.com/img/20240304200123.png)

![](https://obsi-jet.oss-cn-beijing.aliyuncs.com/img/20240304200728.png)
`因为false被包裹成包装类型后就成了对象，所以不是false，所以不会执行if内的内容

**BigInt 的提案的由来**
JavaScriptNumber.MAX_SAFE_INTEGER 表示最⼤安全数字，计算结果是 9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js 就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了 BigInt 来解决此问题。**（为了解决大数计算的准确度）**

**判断一个对象是空对象**

json.stringify;Object.keys
使用 JSON 自带的.stringify 方法来判断；使用 ES6 新增的方法 Object.keys()来判断

**const 对象的属性可以修改吗**
const保证的是变量指向的内存地址不能改动，对于基本数据类型而言，值就保存在变量指向的地址，因此等同于常量，对于引用数据而言，变量保存的是指针，const只能保证指针固定不变，但无法控制指针指向的数据结构是不变的

**如果 new 一个箭头函数的会怎么样**

箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用 arguments 参数，所以不能 New 一个箭头函数
> new 的实现步骤：
> 1.创建一个对象
> 2.将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的 prototype 属性）
> 3.指向构造函数中的代码，构造函数中的 this 指向该对象（也就是为这个对象添加属性和方法）
> 4.返回新的对象。所以，上面的第二、三步，箭头函数都是没有办法执行的

**JavaScript 脚本延迟加载的方式有哪些？**
defer：让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。
async：这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。
动态创建 DOM 方式：动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入js 脚本
使用 setTimeout 延迟方法：设置一个定时器来延迟加载 js 脚本文件
让 JS 最后加载：将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行